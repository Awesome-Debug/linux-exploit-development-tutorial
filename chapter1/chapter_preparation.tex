\chapter{预备}
\par 在这个level 我将要花点时间给大家介绍基本的漏洞类型和安全机制,然后关闭全部的安全
 保护机制,学习如何在Linux下面编写最基本的exp.

 \section{安全机制}
 \par 分为两大类:编译相关(elf加固),部分编译选项控制着生成更安全的代码(损失部分性能或
 者空间),还有就说运行时的安全,都是为增加了漏洞利用的难度,不能从本质上去除软件的
 漏洞.

 \subsection{STACK CANARY}
 \par Canary 是放置在缓冲区和控制数据之间的一个words被用来检测缓冲区溢出, 如果发生缓
 冲区溢出那么第一个被修改的数据通常是canary,当其验证失败通常说明发生了栈溢出,更
 多信息参考这里
 \footnote{\url{https://en.wikipedia.org/wiki/Buffer_overflow_protection\#Canaries}}.
 \begin{lstlisting}[language=sh]
   gcc -fstack-protector
 \end{lstlisting}
 
 \subsection{NX}
 \par 在早期,指令是数据,数据也是数据,当PC指向哪里,那里的数据就会被当成指令被cpu执行,
 后来NX标志位被引入来区分指令和数据.更
 多信息参考这里\cite{Intel}
\footnote{<<Intel® 64 and IA-32 Architectures Software Developer’s Manual>> volumes 3 section 4.6}
\footnote{\url{https://en.wikipedia.org/wiki/NX_bit}}.

 \begin{lstlisting}[language=sh]
   gcc -z execstack
 \end{lstlisting}
 

 \subsection{FORTIFY}
 \par 在编译和运行时候保护glibc:
 \begin{list}{\textbullet}{%
    \setlength\topsep{0pt} \setlength\partopsep{0pt}
    \setlength\parsep{0pt} \setlength\itemsep{0pt}
  }
\item expand unbounded calls to "sprintf", "strcpy" into their "n"
  length-limited cousins when the size of a destination buffer is known
  (protects against memory overflows).
\item stop format string "\%n" attacks when the format string is in a writable \% memory segment. 
\item require checking various important function return codes and arguments (e.g.system, write, open).
\item require explicit file mask when creating new files. 
\end{list}
 \begin{lstlisting}[language=sh]
   gcc -D_FORTIFY_SOURCE=2 -O
 \end{lstlisting}
 
 \subsection{PIE}
 -fPIC:
 类似于-fpic不过克服了部分平台对偏移表尺寸的限制.
 生成可用于共享库的位置独立代码。所有的内部寻址均通过全局偏移表(GOT)完成.要确
 定一个地址,需要将代码自身的内存位置作为表中一项插入.该选项需要操作系统支持,因
 此并不是在所有系统上均有效.该选项产生可以在共享库中存放并从中加载的目标模块.
 参考链接
 \footnote{\url{https://en.wikipedia.org/wiki/Position-independent_code\#PIE}}.
 
 -fPIE:
 这选项类似于-fpic与-fPIC,但生成的位置无关代码只可以链接为可执行文件,它通常的链
 接选项是-pie.
 \begin{lstlisting}[language=sh]
   gcc -pie -fPIE
 \end{lstlisting}

 \subsection{RELRO}
\par Hardens ELF programs against loader memory area overwrites by having the loader mark any areas of the relocation table as read-only for any symbols resolved at
 load-time ("read-only relocations"). This reduces the area of possible
 GOT-overwrite-style memory corruption attacks
 \footnote{\url{http://blog.isis.poly.edu/exploitation\%20mitigation\%20techniques/exploitation\%20techniques/2011/06/02/relro-relocation-read-only/}}.

 \subsubsection{ASLR}
 \footnote{\url{https://en.wikipedia.org/wiki/Address_space_layout_randomization}}

 \section{漏洞类型}
 \subsection{栈溢出}
 \subsection{整数溢出}
 \subsection{off-by-one(stack base)}
 \subsection{格式化字符串}
 \%h(短写)
 \%n\$d(直接参数访问)
 \%n(任意内存写)
 \%s(任意内存读)

 \section{Exp开发}
 \subsection{rop}
 nop seld + shellcode + ret
 \subsection{.dtors(废弃)}
 
 \begin{lstlisting}[language=C]
   static void cleanup() __attribute__((destructor))
 \end{lstlisting}
 \subsection{覆写GOT}
