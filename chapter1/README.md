在这个 level 我将要花点时间给大家介绍基本的漏洞类型和安全机制,然后关闭全部的安全保护机制,学习如何在 Linux 下面编写最基本的 exp.

# 安全机制

分为两大类:编译相关(elf 加固),部分编译选项控制着生成更安全的代码(损失部分性能或者空间),还有就说运行时的安全,都是为增加了漏洞利用的难度,不能从本质上去除软件的漏洞.

## STACK CANARY

Canary 是放置在缓冲区和控制数据之间的一个 words 被用来检测缓冲区溢出,如果发生缓冲区溢出那么第一个被修改的数据通常是 canary,当其验证失败通常说明发生了栈溢出,更多信息参考这里 [^1].

```shell
   gcc -fstack-protector 
```

## NX

在早期,指令是数据,数据也是数据,当 PC 指向哪里,那里的数据就会被当成指令被 cpu 执行,后来 NX 标志位被引入来区分指令和数据.更 多信息参考这里[@Intel] [^2] [^3].

```shell
   gcc -z execstack
```

## PIE

-fPIC: 类似于-fpic 不过克服了部分平台对偏移表尺寸的限制.生成可用于共享库的位置独立代码。所有的内部寻址均通过全局偏移表(GOT)完成.要确定一个地址,需要将代码自身的内存位置作为表中一项插入.该选项需要操作系统支持,因此并不是在所有系统上均有效.该选项产生可以在共享库中存放并从中加载的目标模块.
参考链接 [^4].

-fPIE:
这选项类似于-fpic 与-fPIC,但生成的位置无关代码只可以链接为可执行文件,它通常的链接选项是-pie.

```shell
   gcc -pie -fPIE
```

### RELRO

Hardens ELF programs against loader memory area overwrites by having the loader mark any areas of the relocation table as read-only for any symbols resolved at load-time (“read-only relocations”). This reduces the area of possible GOT-overwrite-style memory corruption attacks [^5].

#### ASLR

[^6]

# 漏洞类型

## 栈溢出

## 整数溢出

## off-by-one(stack base)

## 格式化字符串

%h(短写) %n\$d(直接参数访问) %n(任意内存写) %s(任意内存读)

# Exp 开发

## rop

nop seld + shellcode + ret

## 覆写 GOT

[^1]: <https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries>

[^2]: &lt;&lt;Intel® 64 and IA-32 Architectures Software Developer’s Manual&gt;&gt; volumes 3 section 4.6

[^3]: <https://en.wikipedia.org/wiki/NX_bit>

[^4]: <https://en.wikipedia.org/wiki/Position-independent_code#PIE>

[^5]: <http://blog.isis.poly.edu/exploitation%20mitigation%20techniques/exploitation%20techniques/2011/06/02/relro-relocation-read-only/>

[^6]: <https://en.wikipedia.org/wiki/Address_space_layout_randomization>
